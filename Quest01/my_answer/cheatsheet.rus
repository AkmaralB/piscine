
Игра с текстом в командной строке

Командная строка (также известная как интерфейс командной строки, или CLI, или иногда терминал), представляет собой простой текстовый интерфейс для выполнения команд на компьютере. 
Если вы когда-либо видели фильм о хакерах из 1980-х, например, WarGames, где они смотрят на подсказку на черном экране и вводят команды по одной за раз, это в основном так.

У вас есть приглашение, и вы можете ввести команду и нажать «Enter», чтобы выполнить ее. Пример команды будет:

коснитесь newfile.txt

Эта команда создаст файл с именем newfile.txt.
Как получить доступ к командной строке

Mac OS X: Перейдите в / Applications / Utilities и нажмите «Терминал» или выполните поиск «Терминал» в Spotlight.

Настольный Linux: вы можете искать приложение «Terminal» из Dash. Давайте будем честными, хотя, если вы работаете в Linux, вам, вероятно, не нужен этот учебник.

Windows: Windows - это особый случай. Если вы зайдете в меню «Пуск» и нажмете «Выполнить», а затем наберете «cmd» и нажмете клавишу ввода, откроется версия командной строки для Windows. 
 сожалению, версия командной строки для Windows имеет свою собственную систему, поэтому для целей следующих примеров вы захотите установить Cygwin, что позволит вам имитировать командную строку в стиле Linux:

http://www.cygwin.com/
Немного подробнее

Команды обычно принимают формат:

[имя команды] [опция] [опция] [опция] ...

Подсказка также покажет, в каком каталоге вы сейчас находитесь. Каждый раз, когда вы выполняете команду, вы делаете это из определенного каталога. Это важно, потому что когда вы выполняете команду, которая включает имя файла или имя каталога, вы можете указать это одним из двух способов:
Относительные пути

Указание файла или каталога как относительного пути означает, что вы указываете, где он находится относительно каталога, в котором вы находитесь. Например, предположим, что вы находитесь в подкаталоге videos каталога files. Вы увидите это приглашение:

/ Файлов / видео $

Если вы выполните такую ​​команду, как touch newfile.txt, она создаст newfile.txt внутри текущего каталога. Относительные пути не начинаются с косой черты.
Абсолютные Пути

Указание файла или каталога в качестве абсолютного пути означает, что вы указываете, где он находится на компьютере в абсолютном выражении, начиная с верхнего уровня. Например, допустим, вы снова находитесь в подкаталоге videos каталога files.

/ Файлов / видео $

Если вы выполните такую ​​команду, как touch /files/music/newfile.txt, она создаст newfile.txt в другой папке, музыкальной подпапке папки files. Абсолютные пути начинаются с косой черты.

Если вы используете абсолютный путь, команда будет делать то же самое, независимо от того, из какого каталога вы ее выполняете.

Таким образом, эти две команды будут иметь одинаковый результат из каталога / files / videos:

/ files / videos $ rm video.mp4
(Это удалит файл `video.mp4` из текущей директории)

/ files / videos $ rm /files/videos/video.mp4
(Это удалит `video.mp4` из каталога / files / videos /, который является текущим каталогом)

Те же две команды не будут иметь одинакового результата, если вы находитесь в другом каталоге:

/ files / text $ rm video.mp4
(Это попытается удалить файл video.mp4 из подкаталога 'text', потому что это текущий каталог)

/ files / text $ rm /files/videos/video.mp4
(Это удалит файл из каталога / files / videos /, даже если это не текущий каталог)

Помните:

Начало пути с косой чертой означает, что вы хотите указать полный путь и игнорировать каталог, в котором вы находитесь. Не начинать путь с косой черты означает, что вы хотите указать путь, начиная с каталога, в котором вы находитесь.

Если вы не уверены, в каком каталоге вы находитесь, вы можете использовать команду pwd (Print Working Directory), чтобы получить абсолютный путь к текущему каталогу.

~ $ pwd
/ Users / Noah

Шаблоны файлов

В большинстве случаев, когда вам нужно указать имя файла или имя каталога, вы также можете указать общий шаблон, который может соответствовать нескольким файлам. Есть много входов и выходов с этим, но самая простая версия использует звездочку (*), которая соответствует чему угодно. Это также известно как подстановочный знак.

Удалить любой файл в текущем каталоге
/ files $ rm *

Удалите любой файл, который заканчивается на «.txt»
/ files $ rm * .txt

Удалить любой файл, который начинается с «данных»
/ файлы данных $ rm *

Навигационное

Две основные команды для навигации, в каком каталоге находится приглашение, это cd и ls.

cd - это команда для изменения текущего каталога, за которой должен следовать каталог, в который вы хотите перейти. Вы можете указать абсолютный или относительный путь.

Это поместит вас в / файлы / видео
/ файлы $ cd видео
/ Файлов / видео $

Это поместит вас в / videos, а затем в подкаталог vines.
/ файлы $ cd / videos
/ видео $ cd vines
/ видео / лозы $

Вы можете прыгать несколько уровней одновременно, если хотите.

Это поместит вас в / files / videos / short
/ файлы $ cd videos / short

Вы можете использовать cd .., чтобы перейти на один уровень вверх в родительский каталог.

Это поместит вас в / файлы
/ files / videos $ cd ..

ls выведет список файлов в текущем каталоге. Это полезно для фигури



/ фотографии $ ls
thumbnails photo1.jpg photo2.jpg

Использование ls -l распечатает список по вертикали, с большим количеством другой дополнительной информации о размере файла, разрешениях и дате последнего изменения:

/ фотографии $ ls -l
-rw-rw-r-- 1 noah noah 58133 22 окт. 17:13 photo1.jpg
-rw-rw-r-- 1 noah noah 75640 22 окт. 17:13 photo2.jpg
drwxrwxr-x 2 ноа ноа 4096 22 октября 17:13 эскизы

При вводе в каталог или имя файла, вы можете нажать клавишу «Tab» для автозаполнения, если это возможно. Например, в папке / photos, если вы введете:

/ фотографии $ cd thu

и нажмите «Tab», он заполнит все остальное и покажет вам:

/ фото $ cd миниатюры

Однако, если существует более чем возможный файл / каталог, который соответствует тому, что вы уже ввели, он не будет работать. Если вы введете:

/ фотографии $ рм фо

и нажмите «Tab», ничего не произойдет, потому что вы можете быть на пути к photo1.jpg ИЛИ photo2.jpg.
Вывод команды

Команды, о которых мы поговорим, выводят результаты в виде текста. Когда вы выполняете команду, нажимая «Enter», она выводит связку вывода на дополнительных строках под приглашением. Например, head [file] распечатает первые 10 строк файла.

/ files $ head names.txt
Дэн Синкер
Эрика Оуэнс
Ной Вельтман
Церковь Аннабель
Фридрих Линденберг
Соня песня
Майк Тигас
Брайан Абельсон
Мануэль Аристарэн
Стейн Дебруве
/ Файлы $

Обратите внимание, что после того, как он распечатывает свой вывод, он возвращается к новой подсказке. Распечатывать вывод таким способом вам полезно, если вы просто возитесь, но часто вы хотите сделать одну из двух вещей: отправить вывод в файл или отправить вывод другой команде в качестве ввода.
Отправка вывода в файл

Вы можете отправить вывод в новый файл следующим образом:

/ files $ head names.txt> first10names.txt

Если first10names.txt не существует, он будет создан. Если он уже существует, он будет перезаписан.

Вы можете добавить вывод в конец существующего файла следующим образом:

/ files $ head names.txt >> allnames.txt

Это добавит вывод в виде 10 новых строк в конце allnames.txt.
Отправка вывода другой команде в качестве ввода

Вы можете отправить вывод в другую команду, используя символ канала (|). Команда grep ищет в тексте совпадения (подробнее об этом позже), поэтому вы можете сделать это, чтобы получить первые 10 строк файла, а затем выполнить поиск «Стив» в этих 10 строках:

/ files $ head names.txt | Греп "Стив"

Это в основном то же самое, что и делать это:

/ files $ head names.txt> временный_файл.txt
/ файлы $ grep "Стив" временный_файл.txt

Но вместо того, чтобы сначала отправить вывод в файл, а затем выполнить вторую команду для этого файла, вы перенаправляете вывод непосредственно из первой команды во вторую. Вы можете связать столько, сколько хотите:

/ files $ grep "United States" address.csv | греп "Калифорния" | голова

Это приведет к поиску в файле address.csv строк, содержащих фразу «United States», затем в результатах поиска строки, содержащие слово «California», а затем распечатки первых 10 из этих совпадений.
Grep

Команда grep позволит вам искать фразу (или несколько файлов) по фразе. По умолчанию он распечатает каждую строку, соответствующую вашему запросу.

Распечатайте строки, содержащие слово «darkwing»:

/ files $ grep "darkwing" knownducks.txt

То же, что и выше, но поиск не зависит от регистра:

/ files $ grep -i "darkwing" knownducks.txt

Найти совпадения для точного слова «Дональд» в файле - слова, содержащие «Дональд», например «Макдональд», не будут учитываться:

grep -w "Donald" knownducks.txt

Найти совпадения для "McDuck" в каждом файле в текущем каталоге:

grep "McDuck" *

Найти соответствия для «McDuck» в каждом файле в текущем каталоге И в каждом подкаталоге, вплоть до нижнего уровня:

grep -r "Макдак" *

Для каждого соответствия «Говарда» выведите эту строку И 4 строки после нее (всего 5 строк):

grep -A 4 "Говард" knownducks.txt

Для каждого совпадения «Говарда» выведите эту строку И 4 строки перед ней (всего 5 строк):

grep -B 4 "Говард" knownducks.txt

Для каждого совпадения «Говарда» выведите эту строку И 4 строки перед ней И 4 строки после нее (всего 9 строк):

grep -C 4 "Говард" knownducks.txt

Вместо того, чтобы распечатывать соответствующие строки, распечатайте имена файлов, которые соответствуют вашему поиску:

grep -l "Даффи" *

Просто получите количество совпадений:

grep -c "Даффи" *

Показать номера строк вместе с соответствующими строками:

grep -n "Daffy" knownducks.txt

Кошка

Команда cat объединит несколько файлов вместе. Это напечатает три файла подряд, как если бы они были одним файлом:

cat turkey.txt duck.txt chicken.txt

Помните, что это просто напечатает вывод в ваш терминал. Скорее всего, вы хотите создать новый файл, который объединяет их:

cat turkey.txt duck.txt chicken.txt> turducken.txt

turducken.txt будет содержать все строки в turkey.txt, за которыми следуют все строки в duck.txt, за которыми следуют все строки из chicken.txt.

Если вы хотите объединить ВСЕ файлы в каталоге, вы можете использовать подстановочный знак:

кошка *> ал





